% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mocap_em.R
\name{em}
\alias{em}
\title{EM algorithm to derive zero-inflated negative binomial mixture model parameters}
\usage{
em(count, b, mu1, theta1, mu2, theta2, prob0, prob1, reltol, verbose = FALSE)
}
\arguments{
\item{count}{a list of numeric vectors of cut counts from motif/genomic sampling}

\item{b}{an integer specifying the bootstrap number, where 1 <= b <= length(count)}

\item{mu1}{a numeric value given as the initial guess of the mean parameter of inaccessible component}

\item{theta1}{a numeric value given as the initial guess of the shape paramter of inaccessible component}

\item{mu2}{a numeric value given as the initial guess of the mean parameter of accessible component, requires mu1 << mu2}

\item{theta2}{a numeric value given as the initial guess of the shape paramter of accessible component}

\item{prob0}{a numeric value given as the initial guess of the probability of zero component}

\item{prob1}{a numeric value given as the initial guess of the probability of inaccessible component}

\item{reltol}{a small numeric value specifying the relative tolerance for convergence}
}
\value{
a list of numeric values containing estimates of mu1, theta1, mu2, theta2, prob0, prob1
}
\description{
\code{em} function models cut count as a mixture of zero-inflated negative binomial distributions. 
\code{em} takes as input a set of initial parameter guesses and iteratively updates 
parameter estimation to maximize the log-likelihood function until convergence criteria 
\code{reltol} is met.
}
\examples{
count.all <- sim.count(num=10000,prob0.true=0.01, prob1.true=0.89, mu1.true=10, theta1.true=3, mu2.true=98, theta2.true=5)
##run as a single process
count <- vector("list",1)
size <- length(count.all)/2
count[[1]] <- count.all[sample(length(count.all),size,replace=FALSE)]
res <- em(count,b=1,mu1.init=2,theta1.init=2,mu2.init=200,theta2.init=5,prob0.init=0.05,prob1.init=0.95,1e-10)

##run with multicores
num.boots<-detectCores()
mu1.init <- 0.1
mu2.init <- 10000
theta1.init <- 5.1
theta2.init <- 2.1
prob0.init <- 0.1
prob1.init <- 0.8
count.resp <- vector("list", num.boots)
for (bootstrap in 1:num.boots) {count.resp[[bootstrap]] <- count.all[sample(length(count.all),size,replace=TRUE)]}
res.mat <- mclapply(1:num.boots,FUN = em, count = count.resp,
mu1 = mu1.init,theta1 = theta1.init,mu2 = mu2.init,theta2 = theta2.init,prob0 = prob0.init,prob1=prob1.init,reltol=1e-10,
mc.cores=num.boots,mc.set.seed=FALSE,mc.preschedule=FALSE)
}

